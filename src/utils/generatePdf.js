import html2canvas from "html2canvas";
import { jsPDF } from "jspdf";
import "jspdf-autotable";
import PptxGenJS from "pptxgenjs";
import * as XLSX from 'xlsx';
import { numberToWords } from "./formatValue";
import { convertBlobToDataURL, getCanvasBlob, mergePdfs } from "./fileUtils";
import { convertDateIntoDateMonthYear } from "./dateAndTimeUtils";

window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';

const addHeaderAndFooter = (doc, totalPages) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);

    // Header
    doc.setFont("helvetica", "bold");
    doc.setFontSize(18);
    doc.text(`PROOH TECHNOLOGIES PRIVATE LIMITED`, pageWidth / 2, 15, {
      align: "center",
    });
    doc.setFont("helvetica", "normal");
    doc.setFontSize(10);
    doc.text(
      `Regd. Off: 322-325, 3rd Floor, Paras Trade Center, Gwal Pahari, Sector 2 Gurgaon, Haryana, 122002`,
      pageWidth / 2,
      20,
      { align: "center" }
    );
    doc.setFontSize(10);
    doc.text(
      `CIN-U74999HR2022PTC104131, Email: plan@prooh.ai`,
      pageWidth / 2,
      25,
      { align: "center" }
    );
    doc.line(10, 30, pageWidth - 10, 30);

    // Footer
    doc.line(10, 285, pageWidth - 10, 285);
    doc.text(`Page ${i} of ${totalPages}`, 10, 290);
    doc.text("Generated by PROOH.AI", pageWidth - 10, 290, { align: "right" });
  }
};

const addCostSummaryData = (costData, doc, yOffset) => {
  const PAGE_HEIGHT = doc.internal.pageSize.height; // Total page height
  const FOOTER_MARGIN = 30; // Margin for the footer
  const HEADER_MARGIN = 30; // Margin for the header

  // Function to ensure content fits on the page
  const checkPageBreak = (rowHeight = 0) => {
    if (yOffset + rowHeight > PAGE_HEIGHT - FOOTER_MARGIN) {
      doc.addPage(); // Add a new page
      yOffset = HEADER_MARGIN + 10; // Reset yOffset below the header
    }
  };

  Object.keys(costData)?.forEach((key) => {
    // Add heading for each location
    checkPageBreak(30); // Reserve space for the table header

    doc.setFontSize(12);
    doc.text(key.toUpperCase(), 15, yOffset);
    yOffset += 5;

    // Prepare the data for the table
    const locationDetails = [
      ["Total Screens", Number(costData[key].totalScreens)],
      ["Total Impressions Per Day", Number(costData[key].totalImpression).toFixed(0)],
      ["Total Reach", Number(costData[key].totalReach).toFixed(0)],
      ["Total Slots Per Day", Number(costData[key].totalSlots).toFixed(0)],
      [
        "Total Campaign Budget",
        `INR ${Number(costData[key].totalCampaignBudget).toFixed(0)}`,
      ],
      ["Total CPM", `INR ${Number(costData[key].totalCpm).toFixed(2)}`],
      [
        "Total Price Per Slot",
        `INR ${Number(costData[key].pricePerSlot).toFixed(0)}`,
      ],
    ];

    // Check for page space before adding the table
    checkPageBreak(30); // Reserve space for the table header

    // Add the table with row-specific page break handling
    doc.autoTable({
      body: locationDetails,
      startY: yOffset,
      margin: { top: 10 },
      bodyStyles: {
        fillColor: [255, 255, 255],
        textColor: [0, 0, 0],
      },
      didDrawCell: (data) => {
        if (
          data.row.index === 0 &&
          data.cursor.y + 10 > PAGE_HEIGHT - FOOTER_MARGIN
        ) {
          // If the first cell of the row is exceeding the page, add a new page
          doc.addPage();
          yOffset = HEADER_MARGIN + 10; // Reset yOffset for the new page
          // doc.text(key.toUpperCase(), 15, yOffset - 10); // Redraw the section title
          data.cursor.y = HEADER_MARGIN + 10; // Reset the cursor position for the new page
        }
      },
    });

    // Update yOffset after the table
    yOffset = doc.lastAutoTable.finalY + 20;

    // Check if we need a new page for the next section
    checkPageBreak();
  });

  return yOffset;
};

const addCreativeSummaryData = (creativeData, doc, yOffset) => {
  const PAGE_HEIGHT = doc.internal.pageSize.height; // Get the height of the page
  const FOOTER_MARGIN = 30; // Space reserved for the footer
  const HEADER_MARGIN = 30; // Space reserved for the footer

  // Function to ensure content fits on the page
  const checkPageBreak = (rowHeight = 0) => {
    if (yOffset + rowHeight > PAGE_HEIGHT - FOOTER_MARGIN) {
      doc.addPage(); // Add a new page
      yOffset = HEADER_MARGIN + 10; // Reset yOffset below the header
    }
  };

  Object.keys(creativeData)?.forEach((key) => {
    checkPageBreak(30);
    // Add the section title
    doc.setFontSize(12);
    doc.text(key.toUpperCase(), 15, yOffset);
    yOffset += 5;

    // Prepare table rows
    const tableRows = Object.entries(creativeData[key]).map(
      ([resolution, count]) => [resolution, count]
    );

    // Ensure space for the table; add a new page if necessary
    checkPageBreak(30); // Estimated height for the table header and some rows

    // Add the table
    doc.autoTable({
      head: [["Resolution", "Count"]],
      body: tableRows,
      startY: yOffset,
      margin: { top: 30 },
      theme: "grid",
      didDrawCell: (data) => {
        if (
          data.row.index === 0 &&
          data.cursor.y + 10 > PAGE_HEIGHT - FOOTER_MARGIN
        ) {
          // If the first cell of the row is exceeding the page, add a new page
          doc.addPage();
          yOffset = HEADER_MARGIN + 10; // Reset yOffset for the new page
          doc.text(screen.screenName, 15, yOffset - 10); // Redraw the section title
          data.cursor.y = HEADER_MARGIN + 10; // Reset the cursor position for the new page
        }
      },
    });

    // Update yOffset after the table
    yOffset = doc.lastAutoTable.finalY + 20;

    // Check if the next content requires a page break
    checkPageBreak();
  });

  return yOffset;
};

export const generateCampaignSummaryPdfFromJSON = ({
  preview = false,
  download,
  jsonData,
  fileName,
  heading,
}) => {
  const doc = new jsPDF();
  const campaignApproach = jsonData.approach[0];
  const costSummary = jsonData.costSummary[0];
  const creativeSummary = jsonData.creativeRatio;
  const FOOTER_MARGIN = 30; // Space reserved for the footer
  const HEADER_MARGIN = 30; // Space reserved for the header
  const PAGE_HEIGHT = doc.internal.pageSize.height;
  const PAGE_WIDTH = doc.internal.pageSize.width;

  let yOffset = 40;

  const checkPageBreak = (rowHeight = 0) => {
    if (yOffset + rowHeight > PAGE_HEIGHT - FOOTER_MARGIN) {
      doc.addPage();
      yOffset = HEADER_MARGIN + 10; // Reset to top margin of the new page
    }
  };

  const campaignDetails = [
    ["Name", campaignApproach.name],
    ["Brand Name", campaignApproach.brandName],
    ["Client Name", campaignApproach.clientName],
    ["Campaign Type", `${campaignApproach.campaignType} Plan`],
    ["Industry", campaignApproach.industry],
    ["Start Date", new Date(campaignApproach.startDate).toLocaleString()],
    ["End Date", new Date(campaignApproach.endDate).toLocaleString()],
    ["Duration (days)", `${campaignApproach.duration} Days`],
    ["Markets", campaignApproach.markets.join(", ")],
    ["SOV", `${campaignApproach.sov}/18`],
    ["Total Impressions Per Day", campaignApproach?.totalImpression?.toFixed(0)],
    ["Total CPM", `INR ${campaignApproach?.totalCpm?.toFixed(2) || 0}`],
    ["Total Reach", campaignApproach?.totalReach?.toFixed(0)],
    [
      "Total Campaign Budget",
      `INR ${campaignApproach?.totalCampaignBudget?.toFixed(0) || 0}`,
    ],
    [
      "Discount Availed",
      `${campaignApproach.couponId !== ""
        ? `INR ${campaignApproach.totalDiscount?.toFixed(0)}`
        : "None"
      }`,
    ],
    campaignApproach?.couponId !== ""
      ? [
        "Final Campaign Budget",
        `INR ${campaignApproach.finalCampaignBudget?.toFixed(0) || 0}`,
      ]
      : [
        "Final Campaign Budget",
        `INR ${campaignApproach.totalCampaignBudget?.toFixed(0) || 0}`,
      ],
  ];
  // Campaign Overview
  doc.setFontSize(16);
  doc.text("Campaign Overview", 10, yOffset);
  yOffset += 10;
  checkPageBreak();

  doc.autoTable({
    body: campaignDetails,
    startY: yOffset,
    margin: { top: 30 },
    bodyStyles: {
      fillColor: [255, 255, 255],
      textColor: [0, 0, 0],
    },
    didDrawCell: (data) => {
      if (
        data.row.index === 0 &&
        data.cursor.y + 10 > PAGE_HEIGHT - FOOTER_MARGIN
      ) {
        // If the first cell of the row is exceeding the page, add a new page
        doc.addPage();
        yOffset = HEADER_MARGIN + 10; // Reset yOffset for the new page
        // doc.text(key.toUpperCase(), 15, yOffset - 10); // Redraw the section title
        data.cursor.y = HEADER_MARGIN + 10; // Reset the cursor position for the new page
      }
    },
  });
  yOffset = doc.lastAutoTable.finalY + 10;
  checkPageBreak();

  if (campaignApproach?.type !== "IKnowItAll") {

    // Selected Touchpoints
    doc.setFontSize(12);
    doc.text("Selected Touchpoints", 10, yOffset);
    yOffset += 10;
    checkPageBreak();

    campaignApproach.touchPoints.forEach((point, idx) => {
      doc.setFontSize(10);
      doc.text(`${idx + 1}. ${point}`, 15, yOffset);
      yOffset += 5;
      checkPageBreak();
    });

    yOffset += 5;
    checkPageBreak();

    // Selected Audience Cohorts
    doc.setFontSize(12);
    doc.text("Selected Audience Cohorts", 10, yOffset);
    yOffset += 10;
    checkPageBreak();

    campaignApproach.cohorts.forEach((cohort, idx) => {
      doc.setFontSize(10);
      doc.text(`${idx + 1}. ${cohort}`, 15, yOffset);
      yOffset += 5;
      checkPageBreak();
    });

    yOffset += 5;
    checkPageBreak();
  }

  // Cost Summary
  doc.setFontSize(14);
  doc.text("Cost Summary", 10, yOffset);
  yOffset += 10;
  checkPageBreak();

  yOffset = addCostSummaryData(costSummary, doc, yOffset);

  // Creative Ratio
  doc.setFontSize(14);
  doc.text("Creative Ratio", 10, yOffset);
  yOffset += 10;
  checkPageBreak();

  yOffset = addCreativeSummaryData(creativeSummary, doc, yOffset);

  // Screen-wise Slot Details
  doc.setFontSize(12);
  doc.text(
    "Selected time interval as per selected audience cohorts",
    10,
    yOffset
  );
  yOffset += 10;
  checkPageBreak();

  campaignApproach.screenWiseSlotDetails.forEach((screen, idx) => {
    doc.setFontSize(10);
    doc.text(`${screen.screenName}`, 10, yOffset);
    yOffset += 10;

    doc.autoTable({
      head: [["Day", "Slot"]],
      body: Object.entries(
        screen.slotsInfo.reduce((acc, { day, slot }) => {
          (acc[day.toUpperCase()] ??= []).push(slot.toUpperCase());
          return acc;
        }, {})
      ),
      startY: yOffset,
      margin: { top: 30, left: 15, right: 15 },
      pageBreak: "avoid", // Avoid breaking table across pages
      willDrawPage: (data) => {
        if (data.cursor.y + 10 > PAGE_HEIGHT - FOOTER_MARGIN) {
          doc.addPage();
          yOffset = HEADER_MARGIN + 20;
          doc.text(screen.screenName, 15, yOffset - 10);
          data.cursor.y = HEADER_MARGIN + 10;
        }
      },
      columnStyles: {
        0: { halign: "left", cellWidth: "auto" },
        1: { halign: "left", cellWidth: "auto" },
      },
    });

    yOffset = doc.lastAutoTable.finalY + 20;
    checkPageBreak();
  });

  yOffset += 5;
  checkPageBreak();

  // Header and Footer
  const totalPages = doc.getNumberOfPages();
  addHeaderAndFooter(doc, totalPages);

  if (preview) {
    const pdfBlob = doc.output("blob");
    const url = URL.createObjectURL(pdfBlob);
    window.open(url, "_blank");
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  if (download) {
    doc.save(`${fileName}.pdf`);
  } else {
    const pdfBlob = doc.output("blob");
    return pdfBlob;
  }
};

export const generatePlanSummaryPdfFromJSON = ({
  download,
  jsonData,
  fileName,
  heading,
}) => {
  const doc = new jsPDF();
  let yOffset = 10;
  const lineHeight = 5; // Define consistent line height
  const spaceBetweenSections = 5; // Define space between sections

  // Add the main heading and subheading to the first page
  const addHeading = (heading) => {
    // Main Heading
    doc.setFontSize(18);
    doc.text(heading, 5, yOffset);
    yOffset += lineHeight * 2; // Double the space for heading
  };

  const addPageWithData = (locationData) => {
    Object.keys(locationData)?.forEach((key, index) => {
      if (index > 0) {
        // Add space between each location section
        yOffset += spaceBetweenSections;

        // If space exceeds page height, create a new page
        if (yOffset + 5 > doc.internal.pageSize.height) {
          doc.addPage();
          yOffset = 5; // Reset yOffset for new page
        }
      }

      // Add heading for each location
      doc.setFontSize(16);
      doc.text(key, 5, yOffset);
      yOffset += lineHeight;

      // Prepare the data for the table
      const locationDetails = [
        ["Total Screens", Number(locationData[key].totalScreens) || 0],
        [
          "Total Impressions",
          Number(locationData[key].totalImpression).toFixed(0) || "0",
        ],
        ["Total Reach", Number(locationData[key].totalReach).toFixed(0) || "0"],
        [
          "Total Campaign Budget (In INR)",
          Number(locationData[key].totalCampaignBudget).toFixed(0) || "0",
        ],
        [
          "Total CPM (In INR)",
          Number(locationData[key].totalCpm).toFixed(2) || "0.00",
        ],
      ];

      // Add table for each location's data
      doc.autoTable({
        head: [["Field", "Value"]],
        body: locationDetails,
        startY: yOffset,
        margin: { top: 20 },
      });

      // Adjust yOffset after table
      yOffset = doc.autoTable.previous.finalY + lineHeight;
    });
  };

  // First Page: Add the heading and subheading
  addHeading(heading);

  // Add the location data
  Object.keys(jsonData).forEach((location) => {
    addPageWithData(jsonData[location]);
  });

  // Save the PDF
  if (download) {
    doc.save(`${fileName}.pdf`);
  } else {
    const pdfBlob = doc.output("blob");
    return pdfBlob;
  }
};

export const generateScreenPicturesPptFromJSON = async ({
  download,
  jsonData,
  fileName,
  heading,
}) => {
  const pptx = new PptxGenJS();

  // Create a title slide with the heading
  const titleSlide = pptx.addSlide();
  titleSlide.addText(heading, {
    x: 1,
    y: 1,
    fontSize: 24,
    bold: true,
    color: "000000",
  });

  // Function to add a slide for each screen with details and images
  const addScreenSlide = async (screenData) => {
    const slide = pptx.addSlide();

    // Add screen name
    slide.addText(`Screen Name: ${screenData.screenId}`, {
      x: 0.5,
      y: 0.5,
      fontSize: 18,
      bold: true,
    });

    // Add location details
    slide.addText(
      `Location: ${screenData.location.city}, ${screenData.location.state}, ${screenData.location.country}`,
      { x: 0.5, y: 1, fontSize: 16 }
    );
    slide.addText(`Address: ${screenData.location.address}`, {
      x: 0.5,
      y: 1.5,
      fontSize: 16,
    });
    slide.addText(`TouchPoint: ${screenData.location.touchPoint}`, {
      x: 0.5,
      y: 2,
      fontSize: 16,
    });

    // Check if there are images to load
    if (screenData.images && screenData.images.length > 0) {
      // const imageUrl = "https://cors-anywhere.herokuapp.com/" + screenData.images[0];
      const imageUrl = screenData.images[0];

      try {
        // Add the image to the slide directly by URL (let pptxgenjs handle the loading)
        slide.addImage({ path: imageUrl, x: 0.5, y: 2.5, w: 6, h: 3.5 }); // Adjust image size as necessary
      } catch (error) {
        console.error("Error loading image:", error);
        slide.addText("Image could not be loaded.", {
          x: 0.5,
          y: 2.5,
          fontSize: 16,
          color: "FF0000",
        });
      }
    } else {
      slide.addText("No image available.", {
        x: 0.5,
        y: 2.5,
        fontSize: 16,
        color: "FF0000",
      });
    }

    // Add clickable image URL as fallback
    slide.addText(`Image URL: ${screenData.images[0]}`, {
      x: 0.5,
      y: 6,
      fontSize: 14,
      color: "0000FF",
      hyperlink: { url: screenData.images[0], tooltip: "View Image" },
    });
  };

  // Loop through each screen and add slides
  for (let i = 0; i < jsonData.length; i++) {
    await addScreenSlide(jsonData[i]);
  }

  // Save the PPTX file
  if (download) {
    pptx.writeFile({ fileName: `${fileName}.pptx` });
  } else {
    const pdfBlob = doc.output("blob");
    return pdfBlob;
  }
};

export const generateBillAndInvoicePdf = async ({
  preview = true,
  download = false,
  fileName,
  jsonData,
  billInvoiceDetailsData,
  campaignDetails,
  siteLevelData,
  setBillLoading,
}) => {
  setBillLoading(true);
  const doc = new jsPDF("portrait", "pt", "a4");
  // Generate first page
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const usableWidth = pageWidth - 15 * 2;
  let yOffset = 40; // Reset yOffset for additional pages

  // Function to add a page border
  const addPageBorder = () => {
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;
    doc.setDrawColor(0); // Black border
    doc.setLineWidth(1); // Border thickness
    doc.rect(20, 20, pageWidth - 24, pageHeight - 40, "S");
  };

  // Function to generate the main invoice content
  const generateInvoiceContent = (data, pageWidth, pageHeight, usableWidth, yOffset) => {

      // Header Section (only for first page)
      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.text("TAX INVOICE", pageWidth / 2, yOffset, { align: "center" });
      yOffset += 20;
      doc.setFontSize(10);
      doc.text("PROOH TECHNOLOGIES PRIVATE LIMITED", 30, yOffset);
      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);

      doc.text(`Invoice No: ${data.invoiceNumber}`, 350, yOffset);
      yOffset += 15;
      doc.text(`Contact Person: ${data.planner}`, 30, yOffset);
      doc.text(`Invoice Date: ${data.invoiceDate}`, 350, yOffset);
      yOffset += 15;
      doc.text(`Email Id: ${data.plannerEmail}`, 30, yOffset);
      doc.text(`Internal SO No: ${data.internalSoNumber}`, 350, yOffset);
      yOffset += 15;
      doc.text(`PAN No: AAMCP9602J`, 30, yOffset);
      doc.text(`Client Confirmation: ${data.clientConfirmation}`, 350, yOffset);
      yOffset += 15;
      doc.text(`GST No: 06AAMCP9602J1Z2`, 30, yOffset);
      doc.text(`Client Order Date: ${data.clientOrderDate}`, 350, yOffset);
      yOffset += 15;
      doc.text(``, 30, yOffset);
      doc.text(`Purchase Order No.: ${data.poNumber}`, 350, yOffset);
      yOffset += 15;
      doc.setFont("helvetica", "bold");
      doc.setFontSize(10);

      doc.text("Client Details:-", 30, yOffset);
      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);
      doc.text(`Campaign Name: ${data.campaignName}`, 350, yOffset);
      yOffset += 15;
      doc.setFont("helvetica", "bold");
      doc.setFontSize(10);
      doc.text(`${data.clientAgencyName}`, 30, yOffset);

      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);
      doc.text(
        `Campaign Duration: ${data.startDate} - ${data.endDate}`,
        350,
        yOffset
      );
      yOffset += 15;

      const wrappedAddress = doc.splitTextToSize(
        `${data.officeAddress.address}`,
        250
      );
      doc.text(wrappedAddress, 30, yOffset);
      yOffset += wrappedAddress.length * 8 + 12;
      doc.text(
        `${data.officeAddress.city}, ${data.officeAddress.state}, ${data.officeAddress.country}, ${data.officeAddress.zipCode}`,
        30,
        yOffset
      );
      yOffset += 15;
      doc.text(`Contact Person: ${data?.pocName}`, 30, yOffset);
      yOffset += 15;
      doc.text(`Contact No.: ${data?.pocContact}`, 30, yOffset);
      yOffset += 15;
      doc.text(`Email Id: ${data?.pocEmail}`, 30, yOffset);
      yOffset += 15;
      doc.text(`GSTIN No.: ${data?.gst}`, 30, yOffset);
      yOffset += 15;
      doc.text(`PAN No.: ${data?.pan}`, 30, yOffset);
      yOffset += 15;

    // Table section
    doc.setFontSize(10);
    doc.autoTable({
      head: [["Sr.No", "Description", "HSN/SAC", "Quantity", "Rate", "Amount"]],
      body: [
        [
          "1",
          data.invoiceDescription,
          "998361",
          data.invoiceQuantity,
          Number(data.invoiceAmount).toFixed(0),
          Number(data.invoiceAmount).toFixed(0),
        ],
      ],
      styles: { fontSize: 10, halign: "center" },
      startY: yOffset,
      margin: { top: 30, left: 30, right: 30 },
      tableWidth: usableWidth,
      columnStyles: {
        0: { halign: "center", cellWidth: usableWidth / 15 },
        1: { halign: "left", cellWidth: (5 * usableWidth) / 12 },
        2: { halign: "center", cellWidth: usableWidth / 6 },
        3: { halign: "center", cellWidth: usableWidth / 8 },
        4: { halign: "center", cellWidth: usableWidth / 10 },
        5: { halign: "center", cellWidth: usableWidth / 10 },
      },
    });
    yOffset = doc.lastAutoTable.finalY + 15;
    doc.setFont("helvetica", "bold");
    doc.text(`Sub Total`, 320, yOffset);
    doc.text(`INR ${Number(data.invoiceAmount).toFixed(0)}`, 500, yOffset);
    yOffset += 15;
    doc.line(30, yOffset, pageWidth - 15, yOffset);
    yOffset += 15;
    doc.text(`Amount in words`, 30, yOffset);
    doc.line(pageWidth / 2, yOffset - 15, pageWidth / 2, yOffset + 35);
    doc.text(`Output IGST @${data.outPutGstPercent}%`, 320, yOffset);
    doc.text(`INR ${Number(data.outPutGstAmount).toFixed(2)}`, 500, yOffset);
    yOffset += 15;
    doc.text(`Round Off Amount`, 320, yOffset);
    doc.text(
      `INR ${Number(data.subTotalAmount % 1).toFixed(2)}`,
      500,
      yOffset
    );
    doc.setFont("helvetica", "normal");
    const wrappedText = doc.splitTextToSize(
      `${numberToWords(
        Number(data.subTotalAmount).toFixed(0)
      ).toUpperCase()} ONLY`,
      250
    );
    doc.text(wrappedText, 30, yOffset);
    yOffset += wrappedText.length * 10;
    doc.line(30, yOffset, pageWidth - 15, yOffset);
    yOffset += 15;
    doc.setFont("helvetica", "bold");
    doc.text(`Total: `, 320, yOffset);
    doc.text(
      `INR ${Number(data.subTotalAmount).toFixed(0)} /-`,
      500,
      yOffset
    );
    yOffset += 12;
    doc.line(30, yOffset, pageWidth - 15, yOffset);
    yOffset += 12;

      // Notes section (only on first page)
      doc.text(`NOTE: `, 30, yOffset);
      yOffset += 15;
      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);
      const wrappedNote1 = doc.splitTextToSize(
        `1. The invoice shall be deemed to be accepted, in case no query is raised within 7 days of reciept.`,
        pageWidth - 60
      );
      doc.text(wrappedNote1, 30, yOffset);
      yOffset += 12;

      const wrappedNote2 = doc.splitTextToSize(
        `2. The invoice is due for payment within 15 days from the end date of campaign, unless specified separately, else interest @ 2% per month will be charged from the client.`,
        pageWidth - 60
      );
      doc.text(wrappedNote2, 30, yOffset);
      yOffset += wrappedNote2.length * 8 + 12;

      const wrappedNote3 = doc.splitTextToSize(
        `3. All Cheques/Drafts to be made in favour of "PROOH TECHNOLOGY PRIVATE LIMITED.`,
        pageWidth - 60
      );
      doc.text(wrappedNote3, 30, yOffset);
      yOffset += 12;

      const wrappedNote4 = doc.splitTextToSize(
        `4. GSTN/Billing address: 322, 323, 324 & 325, 3rd Floor, Paras Trade Center, Gurgaon, Faridabad Road, Gwal Pahari, Gurgaon, Haryana, 122002.`,
        pageWidth - 60
      );
      doc.text(wrappedNote4, 30, yOffset);
      yOffset += wrappedNote4.length * 8 + 12;

      const wrappedNote5 = doc.splitTextToSize(
        `5. Bank details for remittance:- A/C Holder Name:- PROOH TECHNOLOGY PRIVATE LIMITED, A/C No.:- 921020001354511, IFSC Code:- UTIB0004373, Bank Name:- Axis Bank, Branch:- Gwal Pahari, Gurgaon, Haryana-122003.`,
        pageWidth - 60
      );
      doc.text(wrappedNote5, 30, yOffset);
      yOffset += wrappedNote5.length * 8 + 12;

      const wrappedNote6 = doc.splitTextToSize(
        `6. Registered address: 322, 323, 324 & 325, 3rd Floor, Paras Trade Center, Gurgaon, Faridabad Road, Gwal Pahari, Gurgaon, Haryana, 122002.`,
        pageWidth - 60
      );
      doc.text(wrappedNote6, 30, yOffset);
      yOffset += wrappedNote6.length * 8 + 12;

      const wrappedNote7 = doc.splitTextToSize(
        `7. All disputes are subject to Gurgaon Jurisdiction.`,
        pageWidth - 60
      );
      doc.text(wrappedNote7, 30, yOffset);
      yOffset += 12;

      const wrappedNote8 = doc.splitTextToSize(
        `8. Whether the tax is payable on reverse charge basis - NO.`,
        pageWidth - 60
      );
      doc.text(wrappedNote8, 30, yOffset);
      yOffset += 15;

      doc.setFont("helvetica", "bold");
      doc.text(
        `Please return this copy on Invoice Duty Signed & Stamped as Token of Acceptance.`,
        pageWidth / 2,
        yOffset,
        { align: "center" }
      );
      yOffset += 12;
      doc.line(30, yOffset, pageWidth - 15, yOffset);
      yOffset += 12;
      doc.text(`Accepted`, 30, yOffset);
      doc.line(pageWidth / 2, yOffset - 12, pageWidth / 2, yOffset + 70);
      doc.text(`For: PROOH TECHNOLOGY PRIVATE LIMITED`, 320, yOffset);
      yOffset += 70;
      doc.line(30, yOffset, pageWidth - 15, yOffset);
      yOffset += 12;
      doc.text(`Stamp`, 30, yOffset);
      doc.line(pageWidth / 2, yOffset - 12, pageWidth / 2, yOffset + 12);
      doc.text(`Authorised Signatory`, 320, yOffset);
      yOffset += 12;
      doc.line(30, yOffset, pageWidth - 15, yOffset);
      yOffset += 15;

      doc.text(`PROOH TECHNOLOGY PRIVATE LIMITED`, 30, yOffset);
      doc.setFont("helvetica", "normal");
      yOffset += 12;
      doc.text(`3rd Floor, Unit No. 322, 323, 324 & 325`, 30, yOffset);
      yOffset += 12;
      doc.text(`Paras Trade Center, Gwal Pahari, Sector 2, Gurugram`, 30, yOffset);
      doc.text(`GSTIN:- 06AAMCP9602J1Z2, Haryana Code:- 06`, 400, yOffset);

      doc.text(`Generated by PROOH.AI`, 490, pageHeight - 8);
  };

  const converUrlToImageBlob = async(url) => {
    const response = await fetch(url);
    const blob = await response.blob();
    const dataUrl = await convertBlobToDataURL(blob);
    return dataUrl
  }

  const addClientConfirmationToPage = async (images, yOffset) => {
    for (const imageUrl of images) {
      const imageDataUrl = await converUrlToImageBlob(imageUrl);
      doc.addImage(
        imageDataUrl,
        'JPEG',
        30, // x position
        yOffset,  // y position
        pageWidth - 50, // width
        280   // height (adjust as needed)
      );
      yOffset += 280;
    }
    return yOffset += 24;
  }

  const addPOPdfToPage = async(uploadedPO, yOffset) => {
    // Load the PDF document
    const loadingTask = window.pdfjsLib.getDocument(uploadedPO);
    const pdf = await loadingTask.promise;
    
    const page = await pdf.getPage(1);
    
    const scale = 1.5;
    const viewport = page.getViewport({ scale });
    
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    
    await page.render({
      canvasContext: context,
      viewport: viewport
    }).promise;
    
    const poBlob = await getCanvasBlob(canvas);
    
    const poImageDataUrl = await convertBlobToDataURL(poBlob);

    doc.addImage(
      poImageDataUrl,
      'JPEG',
      30, // x position
      yOffset,  // y position
      pageWidth - 50, // width
      420   // height (adjust as needed)
    );
    yOffset += 12;
  }

  const dashboardScreenshotsGrid = async (dashboardImages, yOffset) => {
    // Grid configuration
    const cols = 2; // 2 columns
    const rows = 3; // 3 rows
    const marginX = 30; // margin on all sides
    const startY = yOffset; // initial yOffset (top margin)
    const padding = 15; // space between images

    // Calculate image dimensions
    const imgWidth = (pageWidth - 2 * marginX - (cols - 1) * padding) / cols;
    const imgHeight = 240;

    let currentRow = 0;
    let currentCol = 0;

    for (const [index, dImage] of dashboardImages.entries()) {
      // Skip to next page if we've filled the current page
      if (index > 0 && index % (cols * rows) === 0) {
        doc.addPage();
        currentRow = 0;
        currentCol = 0;
      }

      const ssDataUrl = await converUrlToImageBlob(dImage);
      
      // Calculate position
      const x = marginX + currentCol * (imgWidth + padding);
      const y = startY + currentRow * (imgHeight + padding);

      yOffset += 12;
      doc.addImage(
        ssDataUrl,
        'JPEG',
        x,
        y,
        imgWidth,
        imgHeight
      );

      // Move to next grid position
      currentCol++;
      if (currentCol >= cols) {
        currentCol = 0;
        currentRow++;
      }
    }
    return yOffset;
  }

  const addMonitoringPicturesAndLogs = async (screenLevelCampaignData, yOffset) => {
    for (const [index, screen] of screenLevelCampaignData.entries()) {
      // Start a new page for each screen (except the first one)
      if (index > 0) {
        doc.addPage();
        addPageBorder();
        yOffset = 42;
      }
  
      // Add screen header
      doc.setFont("helvetica", "bold");
      doc.text(`Monitoring Pictures: ${screen.screenName}`, 30, yOffset);
      yOffset += 20;
  
      // Draw screen content
      const imgWidth = 60;
      const imgHeight = 40;
      
      doc.roundedRect(30, yOffset - 1, imgWidth + 2, imgHeight + 2, 3, 3, 'S');
      if (screen?.images?.[0]) {
        const imgData = await converUrlToImageBlob(screen.images[0]);
        doc.addImage(imgData, 'JPEG', 31, yOffset, imgWidth, imgHeight);
      } else {
        doc.text(`No Image`, 32, yOffset + 15);
      }
  
      yOffset += 6;
      doc.setFont("helvetica", "bold");
      doc.text(`${screen.screenName}`, 100, yOffset);
      yOffset += 12;
      doc.setFont("helvetica", "normal");
      doc.text(`Touchpoint: ${screen.touchPoint}`, 100, yOffset);
      doc.text(`Start Date: ${convertDateIntoDateMonthYear(campaignDetails.startDate)}`, 420, yOffset);
  
      yOffset += 12;
      doc.text(`Screen Type: ${screen.screenType}`, 100, yOffset);
      doc.text(`End Date: ${convertDateIntoDateMonthYear(campaignDetails.endDate)}`, 420, yOffset);
  
      yOffset += 12;
      doc.text(`Location: ${screen.location}`, 100, yOffset);
      doc.text(`Duration: ${campaignDetails.duration} Days`, 420, yOffset);
  
      yOffset += 12;
      doc.line(30, yOffset, pageWidth - 15, yOffset);
      yOffset += 12;
  
      const CELL_WIDTH = 120;
      const CELL_HEIGHT = 80;
      const IMAGE_PADDING = 2;
  
      // Preload all images for this screen first
      const monitoringEntries = screen.monitoringData?.map(da => ({
        dateType: da.dateType?.split("Date")[0].toUpperCase(),
        date: da.date,
        images: {
          dayShot: da.monitoringTypeWiseData.find(dt => dt.monitoringType === "dayShot")?.monitoringUrls[0]?.awsUrl,
          newspaper: da.monitoringTypeWiseData.find(dt => dt.monitoringType === "withNewspaper")?.monitoringUrls[0]?.awsUrl,
          geoTag: da.monitoringTypeWiseData.find(dt => dt.monitoringType === "withGeoTag")?.monitoringUrls[0]?.awsUrl,
          nightShot: da.monitoringTypeWiseData.find(dt => dt.monitoringType === "nightShot")?.monitoringUrls[0]?.awsUrl
        }
      }));
  
      // Create a 2D array of image promises that matches the table structure
      const imagePromises = monitoringEntries?.map(entry => {
        return [
          entry.images.dayShot ? converUrlToImageBlob(entry.images.dayShot) : Promise.resolve(null),
          entry.images.newspaper ? converUrlToImageBlob(entry.images.newspaper) : Promise.resolve(null),
          entry.images.geoTag ? converUrlToImageBlob(entry.images.geoTag) : Promise.resolve(null),
          entry.images.nightShot ? converUrlToImageBlob(entry.images.nightShot) : Promise.resolve(null)
        ];
      });
  
      // Wait for all images to load before drawing
      const allImages = await Promise.all(imagePromises?.map(row => Promise.all(row)) || []);
  
      // Create table body with proper error handling
      const tableBody = monitoringEntries?.map((da, rowIndex) => {
        const createCell = (columnIndex) => {
          const url = Object.values(da.images)[columnIndex];
          const imgData = allImages[rowIndex]?.[columnIndex];
          
          if (!url) {
            return { 
              content: ' ', // Empty content
              data: { noImage: true } 
            };
          }
          return { 
            content: ' ', // Empty content
            data: { image: url, data: imgData } 
          };
        };
      
        return [
          `${convertDateIntoDateMonthYear(da.date)} \n ${da.dateType}`, // First column remains normal text
          createCell(0),
          createCell(1),
          createCell(2),
          createCell(3)
        ];
      });
  
      // Add monitoring pictures table
      doc.autoTable({
        head: [["Picture Type", "Day Shot", "Newspaper", "GPS", "Night Shot"]],
        body: tableBody,
        styles: { halign: "center", cellPadding: 1, minCellHeight: CELL_HEIGHT },
        headStyles: {
          minCellHeight: 15,
          fillColor: [200, 200, 200],
          textColor: 0,
          cellPadding: { top: 3, right: 1, bottom: 3, left: 1 }
        },
        columnStyles: {
          0: { cellWidth: 65 },
          1: { cellWidth: CELL_WIDTH },
          2: { cellWidth: CELL_WIDTH },
          3: { cellWidth: CELL_WIDTH },
          4: { cellWidth: CELL_WIDTH }
        },
        startY: yOffset,
        margin: { top: 30, left: 30, right: 15 },
        didDrawCell: (data) => {
          if (data.column.index >= 1) {
            const cell = data.cell.raw.data;
            const x = data.cell.x + IMAGE_PADDING;
            const y = data.cell.y + IMAGE_PADDING;
            const width = data.cell.width - (IMAGE_PADDING * 2);
            const height = data.cell.height - (IMAGE_PADDING * 2);
        
            // Clear default text
            doc.setTextColor(255, 255, 255); // "Erase" default text
            doc.text(' ', data.cell.x, data.cell.y);
            doc.setTextColor(0, 0, 0);
        
            if (cell?.noImage) {
              doc.setFontSize(8);
              doc.setTextColor(150, 150, 150);
              const text = "No Image";
              const textWidth = doc.getTextWidth(text);
              doc.text(
                text,
                data.cell.x + (data.cell.width - textWidth) / 2,
                data.cell.y + (data.cell.height / 2) + 3
              );
            } else if (cell?.image) {
              try {
                if (cell.data) {
                  doc.addImage(cell.data, 'JPEG', x, y, width, height);
                } else {
                  throw new Error('Image data missing');
                }
              } catch (error) {
                doc.setFontSize(8);
                doc.text('Load Failed', x + 5, y + 10);
              }
            }
          }
        },
        willDrawCell: (data) => {
          if (data.column.index >= 1) {
            doc.setDrawColor(200);
            doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height);
          }
        }
      });
      
      yOffset = doc.lastAutoTable.finalY + 24;
  
      // Add logs section header on the same page
      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      doc.text("Monitoring Logs:", 30, yOffset);
      doc.setFontSize(8);

      yOffset += 12;
  
      // Fetch and add logs from Excel
      const resp = await fetch(screen.logUrl);
      if (!resp.ok) throw new Error('Failed to fetch file');
      const arrayBuffer = await resp.arrayBuffer();
      const data = new Uint8Array(arrayBuffer);
      const workbook = XLSX.read(data, { type: 'array' });
  
      // Process each worksheet
      for (const sheetName of workbook.SheetNames) {
        const worksheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
  
        // Estimate table height
        const rowCount = rows.length;
        const approxRowHeight = 10; // Adjust based on your font size
        const headerHeight = 15;
        
        // Estimate required space: 12px for title + 8px per row
        const estimatedHeight = headerHeight + (rowCount * approxRowHeight);

        // Check if we need a new page before adding this sheet
        if (yOffset + estimatedHeight > doc.internal.pageSize.height - 50) {
          // Re-add the logs header on new page
          doc.setFont("helvetica", "bold");
          doc.text(`${screen.screenName} Logs:`, 30, yOffset);
          yOffset += 12;
        }
  
        // Add sheet title
        doc.setFont("helvetica", "bold");
        doc.text(`Date: ${sheetName}`, 30, yOffset);
        yOffset += 12;
  
        // Convert to autoTable format
        const tableData = rows.slice(1);
        
        // Add table
        doc.autoTable({
          head: [rows[0]],
          body: tableData,
          startY: yOffset,
          theme: 'grid',
          styles: { fontSize: 8 },
          headStyles: { fillColor: [41, 128, 185] },
          didParseCell: (data) => {
            if (data.row.index === 0) {
              data.cell.styles.fontStyle = 'bold';
            }
          },
          didDrawPage: (data) => {
            // Add screen name on every new page of the table
            if (data.pageNumber > 1) { // Only add on subsequent pages
              doc.setFont("helvetica", "bold");
              doc.text(`Screen: ${screen.screenName}`, 30, 20);
            }
          }
        });
        
        // Update yOffset and check if we're at the bottom
        yOffset = doc.lastAutoTable.finalY + 15;
        
        // Add separator if more sheets remain
        if (workbook.SheetNames.indexOf(sheetName) < workbook.SheetNames.length - 1) {
          doc.line(30, yOffset, pageWidth - 15, yOffset);
          yOffset += 20;
        }
      }
  
      // Add separator at the end of the screen's content
      doc.line(30, yOffset, pageWidth - 15, yOffset);
      yOffset += 20;

      // Force page break before next screen
      if (index < screenLevelCampaignData.length - 1) {
        doc.addPage();
        addPageBorder();
        yOffset = 42;
      }
    }
    return yOffset;
  };

  // Invoice
  addPageBorder();
  generateInvoiceContent(jsonData, pageWidth, pageHeight, usableWidth, yOffset);

  // Client and PO screenshot
  doc.addPage();
  addPageBorder();

  yOffset = 42;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  doc.text(`Client Confirmation Screenshot: `, 30, yOffset);
  doc.setFontSize(8);
  yOffset += 12;
  doc.line(30, yOffset, pageWidth - 15, yOffset);
  yOffset += 12;
  yOffset = await addClientConfirmationToPage(campaignDetails.clientApprovalImgs, yOffset);
  doc.setFontSize(12);
  doc.text(`Client's Purchase Order(PO) Screenshot: `, 30, yOffset);
  doc.setFontSize(8);
  yOffset += 12;
  doc.line(30, yOffset, pageWidth - 15, yOffset);
  doc.setFont("helvetica", "normal");
  yOffset += 12;
  await addPOPdfToPage(billInvoiceDetailsData.uploadedPO, yOffset);


  // Dashboard screenshot
  doc.addPage();
  addPageBorder();

  yOffset = 42;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  doc.text(`Campaign Summary Dashboard Screenshot: `, 30, yOffset);
  doc.setFontSize(8);
  doc.setFont("helvetica", "normal");
  doc.text(`Dated: ${new Date(Number(Object.keys(billInvoiceDetailsData.dashboardScreenshots)[0])).toLocaleString()}`, 450, yOffset);
  yOffset += 12;
  doc.line(30, yOffset, pageWidth - 15, yOffset);
  yOffset += 4;
  await dashboardScreenshotsGrid(Object.entries(billInvoiceDetailsData.dashboardScreenshots)[0][1], yOffset);


  // Monitoring screenshot
  doc.addPage();
  addPageBorder();

  yOffset = 42;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  doc.text(`Monitoring Pictures: `, 30, yOffset);
  doc.setFontSize(8);
  yOffset += 20;
  yOffset = await addMonitoringPicturesAndLogs(siteLevelData, yOffset);
  yOffset += 12;

  // const generatedPdf = doc.output('arraybuffer');

  // const s3Response = await fetch(s3Url);
  // const s3PdfBytes = await s3Response.arrayBuffer();
  
  // // 2. Merge the PDFs using pdf-lib
  // const mergedPdfBytes = await mergePdfs(generatedPdf, s3PdfBytes);

  // // 3. Handle the merged PDF
  // const mergedPdfBlob = new Blob([mergedPdfBytes], { type: 'application/pdf' });

  // if (preview) {
  //   const url = URL.createObjectURL(mergedPdfBlob);
  //   window.open(url, "_blank");
  //   setTimeout(() => URL.revokeObjectURL(url), 1000);
  // }

  // Save the PDF
  if (preview) {
    const pdfBlob = doc.output("blob");
    const url = URL.createObjectURL(pdfBlob);

    window.open(url, "_blank");
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  if (download) {
    doc.save(`${fileName}.pdf`);
  } else {
    const pdfBlob = doc.output("blob");
    return pdfBlob;
  }
  setBillLoading(false);
};


// webpage to pdf
export const generatePdfFromWebPage = async ({
  pageRefs,
  fileName,
  heading,
}) => {
  const pdf = new jsPDF("landscape", "mm", "a4");

  // Add a heading to the PDF
  pdf.setFontSize(18);
  pdf.text(heading, 10, 10);

  // Function to capture and add each section to the PDF
  const captureSection = async (sectionRef, yOffset) => {
    if (sectionRef.current) {
      const canvas = await html2canvas(sectionRef.current, {
        scale: 2, // higher scale for better quality
      });
      const imgData = canvas.toDataURL("image/png");
      const imgWidth = pdf.internal.pageSize.getWidth();
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      pdf.addImage(imgData, "PNG", 0, yOffset, imgWidth, imgHeight);
      return imgHeight; // return the height of the image to calculate next section position
    }
    return 0;
  };

  // Track yOffset for each section
  let yOffset = 20; // starting position, below the heading
  for (let i = 0; i < pageRefs.length; i++) {
    if (i > 0) {
      pdf.addPage(); // Add a new page for each section
      yOffset = 0; // reset yOffset for the new page
    }
    yOffset += await captureSection(pageRefs[i], yOffset);
  }

  // Save the generated PDF
  pdf.save(`${fileName}.pdf`);
};
